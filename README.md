# ☭ Indestructible shield from Lunev ☭
This repository contains programs that will serve as a shield against my expulsion from the flagship of Russian science   

![](https://www.dualshockers.com/wp-content/uploads/2016/05/Screenshot-2016-05-17-12.07.14.png)

# Конспект семинаров
## Sem1

Самая главная команда в UNIX — man **!!!ЧИТАЕМ MAN!!!**

Разделы:

1. System commands

2. System calls

3. Libc

Если хотим получить из второго раздела, то пишем man 2 write
!Гипертекст! - там есть ссылки

Не боимся гуглить, лучше на английском

Отладка: основной отладчик — GDB

gdb filename, breakpoint, run или gdb -p &lt;process&gt; или gdb filename (a.out) core

ulimit говорит о размере core-файла : ulimit -c unlimited

gdb удобен невсегда, тк невсегда есть доступ к исходникам. Для наших программ он в целом не супер нужен, лучше юзать программу strace a.out — печатаются все системные вызовы
-f — флаг, отслеживающий все процессы, порожденные текущим.
-p &lt;pid&gt; - тоже полезно

Флаги компиляции:
-g — чтобы пользоваться отладчиком
-Wall — компилятор намекнет, где может быть ошибка

Задача — написать программу, выводящую числа от 1 до n

## Sem2

fork() - системный вызов, порождающий процессы
Код возврата разный для родительского(pid child) и дочернего процесса(0).

По умолчанию тип pid — int, но правильно юзать pid\_t

команда ps — список процессов текущей сессии

с флагом -axf — всех процессов в системе

getpid() - системный вызов для получения идентификатора текущего процесса

getppid() - получить идентификатор родительского процесса

Как мы стартуем программу?

Exec() - берет образ исполняемого файла и выкидывает, остаются только файловые дескрипторы и разделяемые ресурсы, и запускает заданный файл

Исключение: файлы, открытые с флагом O\_CLOEXEC — они закрываются

Есть разные типы ексеков:

execl

execlpотличие от v: аргументы командной строки как аргуметы

execleфункции, иначе помещабтся в массив)

execvexecv(const char \* filename, char \* const argv\[\]

execve(argv\[0\] = filename))

execvp

Потоки (треды) — независимые потоки исполнения в рамках одного процесса

Процессы — изолированы друг от друга

int pthread\_create(phtread\_t \* id, const pthread\_attr\_t \* attr, void \* (\*run)(void \* arg), void \* arg) — создать поток (0 или меньше 0 — возвращает по ошибке) | указатель на функцию (стартует поток и сразу же эта функция, в качестве аргумента подсунут последний параметр), процесс живет до сих пор, пока родительский поток не прочитает закрытие дочернего

 p = wait(int \* status) (в р — pid, в статус — код возврата). Любой вызов вейт ждет любо порожденный процесс и уничтожает его.

Для тредов — pthread\_join(id); (id получается ещё из создания)

Задача: три раминочных программки

1) Порождение n дочерних процессов, каждый из которых должен вывести свой id, порядковый номер, где порожден, и айди родителя

2) Запускалка произвольной программы с произвольным кол-вом аргументов (x ls -als → x -a -l -s)

3) Породить n потоков, которые инкрементируют одну и ту же переменную (к примеру каждый по 10к раз)

## Sem3

Штатный способ для взаимодействия процессов — использование примитивов:
Pipe — космическая хрень(штруба) с двумя концами — на них файловые дескрипторы (в них можно писать и их можно читать). Данные хранятся внутри ядра. Это некоторый буфер в ядре относительно небольшого размера. Системный вызов:

pipe(int fd\[2\]); fd — пара дескрипторов. В man все написано. Fd1 для записи, 0 для чтения. Существует до сих пор, пока есть хотя бы один файловый дескриптор, который на него ссылается.

Что будет при форк? Дескрипторов станет 4, по паре в каждом процессе. Кол-во ссылок на пайп увеличилось. Если пайп открыт наполовину, то: при закрытом конце на запись чтение вернет накопленные данные и чтение потом будет возвращать 0, больше никогда 0 возвращать чтение из пайпа не будет. Если нет конца не чтение, то произойдет много нехорошего: вернется ошибка и текущий процесс убивается. Сделано так для того, чтобы работала полезная структура:

(основано на системе — каждая утилита делает одну вещь, но делает ее хорошо — основа юникс)

Утилита find . -name \\\*.\[ch\] — найти все файлы с расширением с или h и распечатать на экран. Она умеет хорошо делать одно — искать файлы по написанным правилам.

Поток из стандартного вывода можно завернуть в поток стандартного ввода другой утилиты специальным значком: | (это по сути и есть пайп)

И далее другая утилита: xargs grep myfunc — закидывает все из стандартного ввода в другую утилиту (myfunc) как аргументы. Если нет конца на чтение, то этот конец(xargs) помирает, и зачем тогда делать лишнюю работу (вообще начинать фаинд).

Задание: программа, порождающая дочерний процесс, который читает файл, а родительский процесс печатает этот файл.

Пайп хорош быстротой, но плох тем, что связать можно только родителя и ребенка. Поэтому придумали создавать файл-метку для открытия пайпа, если в двух процесса открыть этот файл, то образуется труба между этими двумя процессами. – FIF0

Системный вызов mkfif0(name, 0644);

open(O\_RDONLY); - блокируется, пока нет конца на запись, т.е. Открытия фифо в режиме O\_WRONLY.

O\_RDWR — в линуксе сразу открывает дескриптор, который можно использовать и для чтения, и для записи. Если есть флаг O\_NONBLOCK, то O\_WRONLY, если нет второго конца, возвращает ошибку, а рдонли все равно открывает дескриптор. Почему так — надо подумать на досуге.

В результате есть некоторые сложности — если будет несколько процессов через один один пайп, а это не оч.

Задача на 1 плюс: написать два процесса(две или одну программу, не отец и ребёнок), т.е. в двух разных терминалах работающие. Первый читает файл, а второй печатает этот файл. Если запускать еще читателя и писателя одновременно с работой первой пары, то файл не должен быть испорчен в процессе передачи. Можно пользоваться только файловым API(опен, рид, врайт), а файловыми локами пользоваться нельзя. Допустим в одной ветке один раз системный вызов слип, но лучше обойтись без него.

## Sem4

Работая с ядром, мы получаем всякие дескрипторы — чиселки. Они иденфицируют всякие объекты и тд. Дескрипторы наследуются через форк. При нем создается новая таблица файловых дескрипторов, которая имеет то же содержимое, что и родители. При ексек все дескрипторы отсаются, кроме тех, кто имели флак о\_клоексек, или фснтл.

Что такое файловый дескриптор? Он содержит внутри себя текущую позицию, с которой происходит чтение и ссылку на следующий объект. Следствие из такой структуры хранения — у одного файла может быть несколько имен — прямая ссылка или жесткая связь. Все объекты удаляются, когда удаляется ссылка на них. Кол-во имен для файла хранится в индексном узле. Если мы хотим получить к нему доступ, есть системный вызов: fstat и stat. Если посмотреть на стрейс, то увидим, что прежде, чем открыть файл, на него зовут стат.

Какие бывают файлы? Обычные и директории. В директорию пользователь писать не может. Директория изменяется через системные вызовы ренейм, анлинм и креейт. Важное свойство — переименование атомарно.

Есть вызовы рид райт опен клоз, есть вызов стат. Есть фцнтл. Анлинк — удаление имени. Опендир, риддир. У фснтл есть сложные флажки — блокировка файлового дескриптора, к примеру. В юниксе локи адвайзери — лок не блокирует опен. Если процесс умер, блокировки на фд отпускаются. Есть OFD блокировки.

Какие бывают имена файлов? Полные и относительные. Относительно текущей директории процесса. Операция открытия файла безумно дорогая. Чтобы упростить операцию открытия используется свойства директории. К файлу приписывается его текущая директория. Setcwd getcwd. Полное имя всегда с /. (/хоум/нейм/1.с). ./1.с и 1.с одно и то же для опен, но для эксек нет. У него другие правила поиска файла. Если ./а.аут, то из текущей директории, а если а.аут, то ищет по всем директориям.

Если дисков несколько, то пофиг. В юниксе одна файловая система. / - корневая директория операционной системы и самого первого диска. Еще один диск присоединятся к текущему дереву файлов системный вызовом mount. Есть обратный вызов — umount.

Сплайс без юзерспейса перекладывает из дескриптора в дескриптор в кернелспейсе.

## Sem5

Кроме пайпа есть очередь сообщений. СистемФайв предложил некоторое количество для межпроцессорной комуникации. Один из них — очередь сообщений

Создаем объект — очередь, на выходе имеем дескриптор этой очереди. Есть системный вызов:
int msgget(key\_t key, int flags). Флаги схои семантикой с флагами опен. IPC\_CREAT, IPC\_EXCL, и права доступа 0666.

Как проверяется, имеем ли мы право открыть файл? Есть пользователь, от лица которого исполняется процесс. Идентификатор получаем через getuid() \\\\ geteuid(). Есть группа пользователь, от которых исполняется процесс. Групп может быть больше одной. И есть все остальные.

Права на файл выглядят так: первые три бита — для пользователя, вторые — для группы, третья группа — все остальные права. Проверяется, совпадают ли идентификаторы пользователя и процесса. Далее, если не совпали, проверяются группы, далее общие. Последовательной проверки нет, только по отдельности на каждые три бита смотрим. Три бита — read ,write, execute. Ексекют для директории — имеем право искать в этой директории.

Какие есть еще битики в правах? Важный битик — suid. Его наличие означает, что если мы запускаем этот исполняемый файл, то юсерайди будет не наш, а тот, которому этот файл принадлежит. (euid поставляется по suid)

Для того, чтобы поменять пароль в системе — надо записать данные в файл etc shedule. Для обычного пользователя этот файл закрыт. Мы запускаем программу пасвд, которая запускается от рута, и может тогда поменять пароль. При попытке в записи файл с сменившемся сюидом ничего не выйдет(к примеру, если скопируем эту программу пасвд).

Руту на все эти права плевать, для него ничего не проверяется.

Откуда брать ключ для мсггет? Можно создать уникальную очередь — IPC\_PRIVATE. Дескриптор унаследуем через форк. А если в разных программа использовать один ключ? Получим один и тот же объект, но нифига не удобно.

Обычно этот ключ генерируют библиотечного вызова ftok(filename, id &lt;0,256&gt;) Айди, чтобы от одного файла генерить несколько разных ключей. Как работает фток — вопрос филосовский kekw.

Вот получили мы айди очереди - msgid. Нужно научиться уничтожать очередь. Для этого есть вызов msgctl. Он умеет больше, так-то. Передаем msgctl(msgid, IPC\_RMID, NULL) и удалим.

Ipcs, ipcrm — две программы, для того, чтобы полистить все объекты из командной строки.

Чтобы послать сообщение в очередь — системный вызов msgsnd(int id, comst void \* message, sie\_t size, int flags) IPC\_NOWAIT — флажок, чтоб не ждать.

Получить сообщение — msgrcv(int id, void \* buff, size\_t len, long msgtype, int flags). Для ознакомления с флагами надо читать man.

С типом все интереснее — посылаемое сообщение должно иметь определенную структуру. Первый лонг по адресу message рассматривается как тип сообщение. Обязательно целое. Размер это не просто размер, а без первого лонга. Ресив хочет получить из очереди первое сообщение с указанным типом, остальные остаются в очереди просто. Если тип — отрицательное число, то вытаскивается первое сообщение с типом, не превосходящим модуль указанного числа. Если указать в ресиве тип ноль, то просто получим сообщение из головы.

После завершения программы очереди не удаляется, их надо удалять САМОМУ.

Программа на 0,5 плюса: породить n детей, а потом каждый ребенок должен напечатать свой порядковый номер. Числа должны вывестись по порядку!!!! Все дочерние процессы — дети корневого. И сначала надо породить все процессы, потом печатать. Печать должна быть в ребенке. Синхронизироваться на очередях сообщений.

## Sem6

Семафор. int semget(key\_t, int n, int flags); Одного семафора мало, поэтому создаем пачку из n семафоров. Создается неинициализированным, но в большинстве систем инициализация нулём.

Semctl().

Для взаимодействия с семафорами нужно использовать системный вызов semop(int fd, struct sembuf \*, int n) — дескриптор, массив операция и колчество операций.

Struct sembuf

{

sem\_num — порядковый номер семафора из набора

sem\_op — чиселко, добавляемое к переменной семафора

sem\_flag — IPC\_NOWAIT — не ждать на семафорной операции(можно указывать только для одной операции), SEM\_UNDO — В момент выполнения операции программа налетела на сегфолт или что-то ещё, то есть умерла так или иначе, поэтому у нас есть возможность в случае смерти процесса откатить какие-то операции. Если умрем, то откатим эту операцию. Но после выполнения другой операции надо обозначить, что больше откатывать не надо — тем же флагом. Есть ещё другие флаги.

}

Как работает внутри? Есть семафор. Для него есть массив(хеш-таблица). Когда выполняем семанду для конкретного процесса, работающего с семафором, анду каунт увеличивается на единицу(вернее на операцию), а после другой операции уменьшается на единицу(операцию). И потом из семафора вычитается анду каунт. То есть возможность вернуть семафор в изначальное значение.

Что такое семафоры - <https://habr.com/ru/post/261273/> <http://www.codenet.ru/progr/cpp/7/3.php>

Разделяемая память. int shmget(key\_t key, size\_t size, int flags)

shmctl();

Получить адрес по системному вызову void \* shmat(int shmid, NULL, 0); (считает количество сегментов\\аттачей)

В 99% случаем нулл и 0. shmdt(void \* addr) - автоматически при смерти процесса. Разблокирут адресс для работы.

Задача на 0,5 плюса: через семафоры и разделяемую память решить первую задачу.



Автор всего этого - Иван Борисенков (ZoomZero)


# Дневник красного воина ☭
* Сделал первые два задания, жду сдачи...
* Лунев отменил семинар, + неделя покодить
* Код первых двух задач прошел ☭.
* К обеим прогам получил первый вопрос.

# Вопросы к задачам
## I
1) Есть ли в коде критические секции?   
Есть - системные вызовы чтения и записи во время работы с transfer fifo, конфликт за память.

## II
1) Есть ли в коде критические секции?   
Есть - конфликт за stdout между детьми. 

# Первое задание (fifo)
## Сжатый алгоритм системных вызовов:
### Reader from file:
open file (O_RDONLY | O_NONBLOCK)   
mkfifo transfer 00600   
open transfer O_RDONLY   
read writer key from transfer    
open writer fifo by key (O_WRONLY | O_NONBLOCK)    
fcntl writer key (O_WRONLY)    
loop: read from file, write to writer fifo    

### Writer to console:
mkfifo transfer    
open transfer (O_WRONLY)    
mkfifo using writer pid (as key)    
open writer fifo (O_RDONLY | O_NONBLOCK)   
write key to transfer    
N times loop: read from writer fifo, sleep(DELAY)    
fcntl writer fifo (O_RDONLY)       
read the remaining    

# Второе задание (messages)
## Сжатый алгоритм:
* Создаем очередь.
* Пораждаем n дочерних процессов.
* Родитель сначала отправляет сообщение типа (n) с любым содержимым, потом ждет сообщение типа (n + 1).
* Каждый сын сначала ждет сообщение типа своего номера, а потом отправляет сообщение   типа (n + 1).
* Закрываем очередь.


# Немного красной символики
![](https://github.com/timattt/Indestructible-shield-from-Lunev/blob/master/MASCOT_STAR.svg)

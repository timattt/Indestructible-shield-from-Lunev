# Содержание
### Полусеместровая 2020
### Полусеместровая не знаю какого года

# Полусеместровая контрольная по информатике
Здесь представлено решение нашей полусеместровой контрольной по информатике.

# Условие (10 вариант)
![](https://www.linkpicture.com/q/0_39.jpg)

# Решение (10 вариант)
## 1.
### Теорминимум
Алгоритмы планирования:
* FCFS - first come, fist served (первым пришел - первым обслужен).    
Просто обычная очередь из процессов, процесс выполняется без прерывания,
пока не завершится, а после берется следующий процесс из очереди.
* SJF - shortes job first (сначала самая короткая работа).    
Очередь процессов сортируется по времени выполнения процесса.
* RR - round robin.    
Каждый процесс выполняется фиксированное небольшое время, после чего
переключаемся на другой процесс, и так пока все процессы не закончат свою работу.
* Приоритетное планирование со статическими приоритетами.
Сортируем процессы по приоритету (грубо говоря по важности процесса),
потом последовательно выполняем самый важный, пока он не завершается,
потом берется и выполняется процесс с меньшим приоритетом и т.д.

### Решение

### a)

Исходя из определений алгоритмов, ясно, что бесконечно откладываться может
процесс в следующих алгосах: 
SJF (ибо долго выполняющийся процесс будет ждать,
если все время запускать быстро выполяющиеся процессы),
Приоритетное планирование со статическими приоритетами (ибо
процесс с низким приоритетом снова будет ждать, если запускать много
процессов с высоким приоритетом).

### б) 
Режим разделения времени предполагает, что у процесса
в любой момент могут забрать или вернуть управление,
поэтому если два процесса находятся в такой ситуации
в режиме гонки, то результат не определен, поэтому
иногда возможен и правильный результат.

## 2.
### Теорминимум 
#### Динамические разделы:
Вначале вся память свободна и не разделена заранее на разделы. Вновь поступающей задаче выделяется строго необходимое количество памяти,
не более. После выгрузки процесса память временно освобождается. По истечении некоторого времени память представляет
собой переменное число разделов разного размера. Смежные свободные участки могут быть объединены.

#### Стратегии работы с памятью:
* Стратегия наиболее подходящего (Best fit).    
Процесс помещается в тот раздел, где после его загрузки останется меньше всего свободного места.
* Стратегия наименее подходящего (Worst fit).     
При помещении в самый большой раздел в нем остается достаточно места для возможного размещения еще одного процесса.
 
#### Краткая сводка алгоритма планирования:
* Имеем очередь готовых процессов.
* Когда хотим что-нибудь выполнять - выбираем процесс
с наименьшим приоритетом и чтобы для него был подходящий по размеру раздел памяти, если таких несколько, то берем тот, который дольше лежит без дела.
* Выполняем выбранный процесс один квант времени.
(ну просто одну единицу времени)
* После выполнения ставим процессу, который мы только что повыполняли изначальный приоритет. 
* Всем остальным процессам в очереди (у которых приоритет больше нуля), уменьшаем приоритет на 1.
* Повторяем эти действия пока процесссы не закончатся.

### a) б)
![](https://i.ibb.co/VHRz3Jp/Second.jpg)
Составляем схему как на рисунке, далее используем алгоритм и заполняем таблицу.
* turnaroundtime - среднее время пребывания процесса в системе, т.е. от нулевого момента времени до момента завершения процесса.
* waitingtime - время ожидания каждого процесса, т.е. когда он есть в системе, но не выполняется.

## 3.
### Теорминимум
* Семафор представляет собой счётчик, над которым можно выполнять две операции: увеличение на 1 и уменьшение на 1. 
При попытке уменьшения семафора, значение которого равно нулю, задача, запросившая данное действие, должна блокироваться до тех пор, пока не станет возможным уменьшение значения
семафора до неотрицательного значения, то есть пока другой процесс не увеличит значение семафора.
* Разделяемая переменная - переменная, общая для всех процессов.
* Монитор – это набор разделяемых переменных и условных переменных, в каждый момент времени только один процесс может выполянться внутри монитора (ожидание выполнением не считается).
Условная переменная монитора - переменная, у которой есть две функции - wait и signal. Первая заставляет процесс ждать до тех пор, пока другой процесс не вызовет вторую.
* Сообщения - можно посылать сообщения между процессами, send(A, mes) A - название очереди, mes - текст. receive(A) - получить из очереди сообщений. receive будет ждать сообщения.

### Решение с монитором
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	Organization.ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	Organization.car_arrived_south();
} else {
	Organization.car_arrived_north();
}
```

Организация:
```
monitor Organization {
	condition south_arrived;
	condition south_ready;
	
	condition north_arrived;
	condition north_ready;

	int count_south = 0; // total cars south
	int count_north = 0; // total cars north
	
	void car_arrived_south() {// хотим переплыть с юга
		count_south++;
		if (count_south >= N) {
			south_ready.signal();
		}
		south_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void car_arrived_north() {// хотим переплыть с севера
		count_north++;
		if (count_south >= N) {
			north_ready.signal();
		}
		north_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void ferry_departure_north() {// паром отплывает с севера
		if (north_count < N) {
			north_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			north_arrived.signal();
		}
		north_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
	
	void ferry_departure_south() {// паром отплывает с юга
		if (south_count < N) {
			south_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			south_arrived.signal();
		}
		count_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
}
```

### Решение с семафорами
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	car_arrived_south();
} else {
	car_arrived_north();
}
```

Организация:
```
semaphor car_north;
semaphor ferry_north;

semaphor car_south;
semaphor ferry_south;
	
void car_arrived_south() {// хотим переплыть с юга
	V(ferry_south);//up
	P(car_south);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void car_arrived_north() {// хотим переплыть с севера
	V(ferry_north);//up
	P(car_north);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void ferry_departure_north() {// паром отплывает с севера
	for (int i = 0; i < N; i++) {
		P(ferry_north);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_north);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}
	
void ferry_departure_south() {// паром отплывает с юга
	for (int i = 0; i < N; i++) {
		P(ferry_south);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_south);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}

```

### Решение с сообщениями
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	car_arrived_south();
} else {
	car_arrived_north();
}
```

Организация:
```
queue car_north;
queue ferry_north;

queue car_south;
queue ferry_south;
	
void car_arrived_south() {// хотим переплыть с юга
	send(ferry_south, "I arrived!");
	receive(car_south);
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void car_arrived_north() {// хотим переплыть с севера
	send(ferry_north, "I arrived!");
	receive(car_north);
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void ferry_departure_north() {// паром отплывает с севера
	for (int i = 0; i < N; i++) {
		receive(ferry_north);
	}
	for (int i = 0; i < N; i++) {
		send(car_north, "lets go");
	}
	
	// паром отплывает
	// плывет
	// выгружает
}
	
void ferry_departure_south() {// паром отплывает с юга
	for (int i = 0; i < N; i++) {
		receive(ferry_south);
	}
	for (int i = 0; i < N; i++) {
		send(car_south, "lets go");
	}
	
	// паром отплывает
	// плывет
	// выгружает
}

```


## 4.
### Теорминимум
[Хорошее видео](https://youtu.be/1x71GUNcS2s)   

### Решение
Всего у адреса 32 бита. Но 512 = 2^9, т.е. 9 битов на сегмент.
Еще 256кб = 2^18. Т.е. на адрес 18 бит. Соответственно на страницу 32 - 18 - 9 = 5.

0x15abcd = 00000000000101011010101111001101
0x951234 = 00000000100101010001001000110100
0xfb1421 = 00000000111110110001010000100001

Перевели в двоичное представление.
Теперь разобьем на колонки по соответсвующей длине сегмента, страницы, логического адреса.
(первая - сегмент, вторая - адрес, третья - лог. адрес)

0x15abcd = 000000000 00101 011010101111001101   
0x951234 = 000000001 00101 010001001000110100    
0xfb1421 = 000000001 11110 110001010000100001       

0x15abcd = 000000000 00101 011010101111001101      
	=> сегмент 0, страница 5, берем соответствуюший номер кадра: 18 = 10010, к нему приписываем справа лог. адрес и переводим в 16тиричную, имеем 0x49ABCD.   
0x951234 = 000000001 00101 010001001000110100     
	=> сегмент 1, страница 5, такой страницы у нас нет, поэтому page fault.      
0xfb1421 = 000000001 11110 110001010000100001          
  	=> сегмент 1, важно, чтобы число, которое получается приписыванием друг к другу второй и третьей колонки были меньше соответсвующей длины сегмента, что не наблюдается здесь, поэтому error. 


# Полусеместровая контрольная не знаю, какого года
[Открой меня!](https://github.com/timattt/Indestructible-shield-from-Lunev/blob/master/HalfSemesterKR/Solutions_old/KR_STRANGE_YEAR.pdf)

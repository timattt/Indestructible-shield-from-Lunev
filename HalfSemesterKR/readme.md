# Содержание
### Полусеместровая 2020
### Полусеместровая не знаю какого года

# Полусеместровая контрольная по информатике
Здесь представлено решение нашей полусеместровой контрольной по информатике.

# Условие (10 вариант)
![](https://www.linkpicture.com/q/0_39.jpg)

# Решение (10 вариант)
## 1.
### a)

Алгоритмы планирования:
* FCFS - first come, fist served (первым пришел - первым обслужен).    
Просто обычная очередь из процессов, процесс выполняется без прерывания,
пока не завершится, а после берется следующий процесс из очереди.
* SJF - shortes job first (сначала самая короткая работа).    
Очередь процессов сортируется по времени выполнения процесса.
* RR - round robin.    
Каждый процесс выполняется фиксированное небольшое время, после чего
переключаемся на другой процесс, и так пока все процессы не закончат свою работу.
* Приоритетное планирование со статическими приоритетами.
Сортируем процессы по приоритету (грубо говоря по важности процесса),
потом последовательно выполняем самый важный, пока он не завершается,
потом берется и выполняется процесс с меньшим приоритетом и т.д.

Исходя из определений, ясно, что бесконечно откладываться может
процесс в следующих алгосах: 
SJF (ибо долго выполняющийся процесс будет ждать,
если все время запускать быстро выполяющиеся процессы),
Приоритетное планирование со статическими приоритетами (ибо
процесс с низким приоритетом снова будет ждать, если запускать много
процессов с высоким приоритетом).

### б) 
Режим разделения времени предполагает, что у процесса
в любой момент могут забрать или вернуть управление,
поэтому если два процесса находятся в такой ситуации
в режиме гонки, то результат не определен, поэтому
иногда возможен и правильный результат.

## 2.
### Динамические разделы:
Вначале вся память свободна и не разделена заранее на разделы. Вновь поступающей задаче выделяется строго необходимое количество памяти,
не более. После выгрузки процесса память временно освобождается. По истечении некоторого времени память представляет
собой переменное число разделов разного размера. Смежные свободные участки могут быть объединены.

### Стратегии работы с памятью:
* Стратегия наиболее подходящего (Best fit).    
Процесс помещается в тот раздел, где после его загрузки останется меньше всего свободного места.
* Стратегия наименее подходящего (Worst fit).     
При помещении в самый большой раздел в нем остается достаточно места для возможного размещения еще одного процесса.
 
### Краткая сводка алгоритма планирования:
* Имеем очередь готовых процессов.
* Когда хотим что-нибудь выполнять - выбираем процесс
с наименьшим приоритетом и чтобы для него был подходящий по размеру раздел памяти, если таких несколько, то берем тот, который дольше лежит без дела.
* Выполняем выбранный процесс один квант времени.
(ну просто одну единицу времени)
* После выполнения ставим процессу, который мы только что повыполняли изначальный приоритет. 
* Всем остальным процессам в очереди (у которых приоритет больше нуля), уменьшаем приоритет на 1.
* Повторяем эти действия пока процесссы не закончатся.

### a)
![](https://i.ibb.co/VHRz3Jp/Second.jpg)
Составляем схему как на рисунке, далее используем алгоритм и заполняем таблицу.
* turnaroundtime - среднее время пребывания процесса в системе, т.е. от нулевого момента времени до момента завершения процесса.
* waitingtime - время ожидания каждого процесса, т.е. когда он есть в системе, но не выполняется.

## 3.
### Теорминимум
* Семафор представляет собой счётчик, над которым можно выполнять две операции: увеличение на 1 и уменьшение на 1. 
При попытке уменьшения семафора, значение которого равно нулю, задача, запросившая данное действие, должна блокироваться до тех пор, пока не станет возможным уменьшение значения
семафора до неотрицательного значения, то есть пока другой процесс не увеличит значение семафора.
* Разделяемая переменная - переменная, общая для всех процессов.
* Монитор – это набор разделяемых переменных и условных переменных, в каждый момент времени только один процесс может выполянться внутри монитора (ожидание выполнением не считается).
Условная переменная монитора - переменная, у которой есть две функции - wait и signal. Первая заставляет процесс ждать до тех пор, пока другой процесс не вызовет вторую.

### Решение с монитором
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	Organization.ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	Organization.car_arrived_south();
} else {
	Organization.car_arrived_north();
}
```

Организация:
```
monitor Organization {
	condition south_arrived;
	condition south_ready;
	
	condition north_arrived;
	condition north_ready;

	int count_south = 0; // total cars south
	int count_north = 0; // total cars north
	
	void car_arrived_south() {// хотим переплыть с юга
		count_south++;
		if (count_south >= N) {
			south_ready.signal();
		}
		south_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void car_arrived_north() {// хотим переплыть с севера
		count_north++;
		if (count_south >= N) {
			north_ready.signal();
		}
		north_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void ferry_departure_north() {// паром отплывает с севера
		if (north_count < N) {
			north_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			north_arrived.signal();
		}
		north_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
	
	void ferry_departure_south() {// паром отплывает с юга
		if (south_count < N) {
			south_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			south_arrived.signal();
		}
		count_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
}
```

### Решение с симафорами
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	car_arrived_south();
} else {
	car_arrived_north();
}
```

Организация:
```
shared int count_south = 0; // total cars south
shared int count_north = 0; // total cars north

semaphor car_north;
semaphor ferry_north;

semaphor car_south;
semaphor ferry_south;
	
void car_arrived_south() {// хотим переплыть с юга
	V(ferry_south);//up
	P(car_south);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void car_arrived_north() {// хотим переплыть с севера
	V(ferry_north);//up
	P(car_north);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void ferry_departure_north() {// паром отплывает с севера
	for (int i = 0; i < N; i++) {
		P(ferry_north);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_north);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}
	
void ferry_departure_south() {// паром отплывает с юга
	for (int i = 0; i < N; i++) {
		P(ferry_south);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_south);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}

```

# Полусеместровая контрольная не знаю, какого года
[Открой меня!](https://github.com/timattt/Indestructible-shield-from-Lunev/blob/master/HalfSemesterKR/Solutions_old/KR_STRANGE_YEAR.pdf)

# Содержание
## Полусеместровая 2020
## Полусеместровая не знаю какого года

# Полусеместровая контрольная по информатике
Здесь представлено решение нашей полусеместровой контрольной по информатике.

# Условие (10 вариант)
![](https://www.linkpicture.com/q/0_39.jpg)

# Решение (10 вариант)
## 1.
### a)

Алгоритмы планирования:
* FCFS - first come, fist served (первым пришел - первым обслужен).    
Просто обычная очередь из процессов, процесс выполняется без прерывания,
пока не завершится, а после берется следующий процесс из очереди.
* SJF - shortes job first (сначала самая короткая работа).    
Очередь процессов сортируется по времени выполнения процесса.
* RR - round robin.    
Каждый процесс выполняется фиксированное небольшое время, после чего
переключаемся на другой процесс, и так пока все процессы не закончат свою работу.
* Приоритетное планирование со статическими приоритетами.
Сортируем процессы по приоритету (грубо говоря по важности процесса),
потом последовательно выполняем самый важный, пока он не завершается,
потом берется и выполняется процесс с меньшим приоритетом и т.д.

Исходя из определений, ясно, что бесконечно откладываться может
процесс в следующих алгосах: 
SJF (ибо долго выполняющийся процесс будет ждать,
если все время запускать быстро выполяющиеся процессы),
Приоритетное планирование со статическими приоритетами (ибо
процесс с низким приоритетом снова будет ждать, если запускать много
процессов с высоким приоритетом).

### б) 
Режим разделения времени предполагает, что у процесса
в любой момент могут забрать или вернуть управление,
поэтому если два процесса находятся в такой ситуации
в режиме гонки, то результат не определен, поэтому
иногда возможен и правильный результат.

## 2.
### Динамические разделы:
Вначале вся память свободна и не разделена заранее на разделы. Вновь поступающей задаче выделяется строго необходимое количество памяти,
не более. После выгрузки процесса память временно освобождается. По истечении некоторого времени память представляет
собой переменное число разделов разного размера. Смежные свободные участки могут быть объединены.

### Стратегии работы с памятью:
* Стратегия наиболее подходящего (Best fit).    
Процесс помещается в тот раздел, где после его загрузки останется меньше всего свободного места.
* Стратегия наименее подходящего (Worst fit).     
При помещении в самый большой раздел в нем остается достаточно места для возможного размещения еще одного процесса.
 
### Краткая сводка алгоритма планирования:
* Имеем очередь готовых процессов.
* Когда хотим что-нибудь выполнять - выбираем процесс
с наименьшим приоритетом и чтобы для него был подходящий по размеру раздел памяти, если таких несколько, то берем тот, который дольше лежит без дела.
* Выполняем выбранный процесс один квант времени.
(ну просто одну единицу времени)
* После выполнения ставим процессу, который мы только что повыполняли изначальный приоритет. 
* Всем остальным процессам в очереди (у которых приоритет больше нуля), уменьшаем приоритет на 1.
* Повторяем эти действия пока процесссы не закончатся.

### a)
![](https://i.ibb.co/VHRz3Jp/Second.jpg)
Составляем схему как на рисунке, далее используем алгоритм и заполняем таблицу.
* turnaroundtime - среднее время пребывания процесса в системе, т.е. от нулевого момента времени до момента завершения процесса.
* waitingtime - время ожидания каждого процесса, т.е. когда он есть в системе, но не выполняется.

## 3.
### Теорминимум
* Семафор представляет собой счётчик, над которым можно выполнять две операции: увеличение на 1 и уменьшение на 1. 
При попытке уменьшения семафора, значение которого равно нулю, задача, запросившая данное действие, должна блокироваться до тех пор, пока не станет возможным уменьшение значения
семафора до неотрицательного значения, то есть пока другой процесс не увеличит значение семафора.
* Разделяемая переменная - переменная, общая для всех процессов.
* Монитор – это набор разделяемых переменных и условных переменных, в каждый момент времени только один процесс может выполянться внутри монитора (ожидание выполнением не считается).
Условная переменная монитора - переменная, у которой есть две функции - wait и signal. Первая заставляет процесс ждать до тех пор, пока другой процесс не вызовет вторую.

### Решение с монитором
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	Organization.ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	Organization.car_arrived_south();
} else {
	Organization.car_arrived_north();
}
```

Организация:
```
monitor Organization {
	condition south_arrived;
	condition south_ready;
	
	condition north_arrived;
	condition north_ready;

	int count_south = 0; // total cars south
	int count_north = 0; // total cars north
	
	void car_arrived_south() {// хотим переплыть с юга
		count_south++;
		if (count_south >= N) {
			south_ready.signal();
		}
		south_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void car_arrived_north() {// хотим переплыть с севера
		count_north++;
		if (count_south >= N) {
			north_ready.signal();
		}
		north_arrived.wait();
		
		// поднимаемся на паром
		// плывем
		// спускаемся
	}
	
	void ferry_departure_north() {// паром отплывает с севера
		if (north_count < N) {
			north_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			north_arrived.signal();
		}
		north_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
	
	void ferry_departure_south() {// паром отплывает с юга
		if (south_count < N) {
			south_ready.wait();
		}
		for (int i = 0; i < N; i++) {
			south_arrived.signal();
		}
		count_south -= N;
		
		// паром отплывает
		// плывет
		// выгружает
	}
}
```

### Решение с симафорами
Действия процессов:     
Паром:
```
while (!ferry->tired()) {
	ferry_departure_north();
	// паром отплывает с юга
	// плывет к северу
	// выгружает на севере
	ferry_departure_south();
	// паром отплывает с севера
	// плывет к югу
	// выгружает на юге
}
```

Водитель:
```
if (driver.isGoingFromSouth()) {
	car_arrived_south();
} else {
	car_arrived_north();
}
```

Организация:
```
shared int count_south = 0; // total cars south
shared int count_north = 0; // total cars north

semaphor car_north;
semaphor ferry_north;

semaphor car_south;
semaphor ferry_south;
	
void car_arrived_south() {// хотим переплыть с юга
	V(ferry_south);//up
	P(car_south);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void car_arrived_north() {// хотим переплыть с севера
	V(ferry_north);//up
	P(car_north);//down
	
	// поднимаемся на паром
	// плывем
	// спускаемся
}
	
void ferry_departure_north() {// паром отплывает с севера
	for (int i = 0; i < N; i++) {
		P(ferry_north);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_north);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}
	
void ferry_departure_south() {// паром отплывает с юга
	for (int i = 0; i < N; i++) {
		P(ferry_south);//down
	}
	for (int i = 0; i < N; i++) {
		V(car_south);
	}
	
	// паром отплывает
	// плывет
	// выгружает
}

```

# Полусеместровая не знаю какого года
1. Верно ли утверждение «Если для двух процессов не выполнены условия Бернстайна, то они образуют недетерминированный набор»? Если Ваш ответ «да» - докажите, если «нет» - приведите контрпример.
2. Для чего в мониторах Хора вводятся условные переменные? Приведите пример их использования.
3. В чем заключается разница между процессами и нитями исполнения (thread&#39;ами), реализованными на уровне ядра ОС?

_ **Решение:** _

1. Утверждение неверно. Рассмотрим набор из двух процессов с одинаковым кодом из двух атомарных операций: x = 2; у = x+3; Все условия Бернстайна нарушены – набор, тем не менее, детерминирован.
2. Условные переменные в мониторах Хора, как правило, применяются для взаимной синхронизации процессов, требующейся для обеспечения правильной очередности их доступа к разделяемым ресурсам (поскольку взаимоисключения обеспечивает сама конструкция мониторов). Пример — ну, скажем, см. в лекциях — решение задачи producer-consumer.
3. В системах, поддерживающих нити исполнения на уровне ядра, thread&#39;ы представляют собой единицы исполнения, а процессы — единицы выделения ресурсов. Процесс представляется как совокупность взаимодействующих нитей и выделенных ему ресурсов. Нити процесса разделяют его программный код, глобальные переменные и системные ресурсы, но каждая нить имеет свой собственный программный счетчик, свое содержимое регистров и свой собственный стек. Планирование использования процессора происходит в терминах нитей, а управление памятью и другими системными ресурсами остается в терминах процессов.

1. (6 баллов) Рассмотрим однопроцессорную одноядерную вычислительную систему с объемом свободной оперативной памяти 220 Mb, в которой используется схема организации памяти с динамическими (переменными) разделами. Для долгосрочного планирования процессов в ней применен алгоритм планирования с приоритетами. В систему поступают пять заданий с различной длительностью, различным объемом занимаемой памяти и различными приоритетами по следующей схеме:

| Номер задания | Момент поступления в очередь заданий | Время исполнения (CPU burst) | Объем занимаемой памяти | Приоритет |
| --- | --- | --- | --- | --- |
| 1 | 0 | 6 | 60 Mb | 2 |
| 2 | 0 | 3 | 100 Mb | 1 |
| 3 | 3 | 4 | 60 Mb | 3 |
| 4 | 4 | 3 | 80 Mb | 1 |
| 5 | 5 | 2 | 20 Mb | 2 |

Нарисуйте диаграмму использования оперативной памяти, вычислите среднее время между стартом задания и его завершением (turnaroundtime) и среднее время ожидания (waitingtime) для следующей комбинации алгоритма краткосрочного планирования и стратегии размещения процессов в памяти:

Вытесняющий SJF (ShortestJobFirst) и worstfit (наименее подходящий);

При вычислениях считать, что процессы не совершают операций ввода-вывода. Временами переключения контекста, рождения процессов и работы алгоритмов планирования пренебречь. Освобождение памяти, занятой процессами, происходит немедленно по истечении их CPUburst. Краткосрочное планирование осуществляется после рождения новых процессов в текущий момент времени. Наивысшим приоритетом в системе является приоритет со значением 0.

_ **Решение:** _

Рассмотрим выполнение процессов в системе для вытесняющего алгоритма SJF и стратегии worstfit. По вертикали в таблице отложены номера процессов, по горизонтали — промежутки времени. Столбец 0 соответствует временному интервалу от 0 до 1. Буква «И» означает состояние исполнения, буква «Г» — состояние готовности, буква «О» — ожидание в очереди заданий. Под таблицей приведено распределение памяти, а еще ниже — содержимое очереди заданий.

|
 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | Г | Г | Г | Г | Г | Г | Г | Г | Г | Г | Г | Г | И | И | И | И | И | И |
| 2 | И | И | И |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
| 3 |
 |
 |
 | И | И | И | И |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
| 4 |
 |
 |
 |
 | О | О | О | Г | Г | И | И | И |
 |
 |
 |
 |
 |
 |
| 5 |
 |
 |
 |
 |
 | О | О | И | И |
 |
 |
 |
 |
 |
 |
 |
 |
 |

| P2
 100 | P2
 100 | P2
 100 | P3
 60 | P3
 60 | P3
 60 | P3
 60 | P4
 80 | P4
 80 | P4
 80 | P4
 80 | P4
 80 | 100 | 100 | 100 | 100 | 100 | 100 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 40 | 40 | 40 | 40 |
| 20 | 20 | 20 | 20 | 20 |
| P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 | P1
 60 |
| 60 | 60 | 60 | 60 | 60 | 60 | 60 | P5
 20 | P5
 20 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 |
| 40 | 40 |

![](RackMultipart20201029-4-1awouz_html_b8cae042fa18c21e.png)

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|
 |
 |
 |
 | P4 | P4 | P4 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
|
 |
 |
 |
 |
 | P5 | P5 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |
 |

Среднее время между стартом задания и его завершением: tt = (18 + 3 + 4 + 8 + 4)/5 = 7.4
 Среднее время ожидания: wt = (12 + 0 + 0 + 5 + 2)/5 = 3.8.

1. (3 балла) В вычислительной системе с сегментно-страничной организацией памяти и 32-х битовым адресом максимальный размер сегмента составляет 8 Mb, а размер страницы памяти 512 Kb. Для некоторого процесса в этой системе таблица сегментов имеет вид:

| Номер сегмента | Длина сегмента |
| --- | --- |
| 0 | 0x500000 |
| 1 | 0x3e0000 |

Таблицы страниц, находящихся в памяти, для сегментов 0 и 1 приведены ниже:

| Сегмент 0 |
 | Сегмент 1 |
| --- | --- | --- |
| Номер страницы | Номер кадра(десятичный) |
 | Номер страницы | Номер кадра(десятичный) |
| 0 | 19 |
 | 1 | 12 |
| 3 | 7 |
 | 3 | 63 |
| 6 | 0 |
 | 7 | 32 |

Каким физическим адресам соответствуют логические адреса: 0x00ac3145, 0х00d17281, 0x009a1530?

_ **Решение:** _

8 Mb — это 223 байт, т.е. под номер сегмента в логическом адресе отводится 9 бит, а 23 бита — под смещение внутри сегмента. Размер страницы 512 Kb — это 219 байт, т.е. из смещения внутри сегмента 19 бит отводится под смещение внутри страницы, а 4 бита — под номер страницы.

**0**** x ****00**** ac ****3145** —\&gt; сегмент 1, смещение 0x2c3145 —\&gt; сегмент 1, страница 5, смещение 0x00043145 —\&gt;  **page**** fault**.

**0**** x ****00**** d ****17281** —\&gt; сегмент 1, смещение 0x517281 —\&gt; смещение больше размеров сегмента —\&gt; **segmentation**** fault**.

**0**** x ****0**** 09 ****a**** 1530** —\&gt; сегмент 1, смещение 0x001a1530 —\&gt; сегмент 1, страница 3, смещение 0x00021530 — \&gt;
 кадр 63, смещение 0x00021530 —\&gt; кадр 0x3f, смещение 0x00021530 —\&gt; 0x01f80000+0x00021530 —\&gt; **0**** x ****01**** fa ****1530.**

1. (12 баллов) На Урале в карьере открытым способом ведется добыча породы, содержащей железную руду. Самосвалы отвозят породу с рудой на обогатительную фабрику, а обратно с фабрики на отвалы карьера везут отработанную пустую породу. На дороге между карьером и фабрикой находится узкий хлипкий мост. Машины, едущие в одном направлении, могут переезжать мост одновременно, а в противоположных — нет. Мост выдерживает не более двух машин. Машины, ждущие въезда на мост, начинают по нему движение, как только появляется такая возможность. Используя классические мониторы Хора, постройте корректную модель проезда через мост, описав движение каждого самосвала с помощью отдельного процесса.

_ **Возможное** __**решение**__ **:** _

Считаем, что мост расположен с севера на юг.

monitor Bridge {

conditionN, S; // условные переменные для ожидания въезда на мост с севера и с юга

intCount, Dir; // количество машин на мосту и направление движения: 1 или 2

void north\_entry(void){ // въездссевера

if (Count == 2 || (Count == 1 &amp;&amp; Dir != 1) N.wait;

Count++; Dir = 1;

if (Count == 1) N.signal;

}

void south\_entry(void) { // въездсюга

if (Count == 2 || (Count == 1 &amp;&amp; Dir != 2) S.wait;

Count++; Dir = 2;

if(Count == 1) S.signal;

}

voidnorth\_exit(void) { // выезд с севера на юг

Count--;

if (Count == 1) N.signal;

else if (Count == 0) S.signal;

}

voidsouth\_exit(void) { // выезд с юга на север

Count--;

if (Count == 1) S.signal;

else if (Count == 0) N.signal;

}

{

Count = Dir = 0;

}

}

Процесс самосвал:

while(1) {

Загрузиться на карьере.

Доехать до моста.

Bridge.north\_entry();

Проехать мост

Bridge.north\_exit();

Выгрузка и погрузка на фабрике.

Доехать до моста.

Bridge.south\_entry();

Проехать мост

Bridge.south\_exit();

Выгрузка на карьере.

}

_ **Оценка:** _

Грубые ошибки: тупиковые ситуации, лобовое столкновение машин, мост рухнул — -9 баллов. Ошибки средней тяжести: циклы активного ожидания, сначала все едут в одну сторону, потом – все в другую — -6 баллов Полный балл только за полностью правильный ответ. Любая попытка решения должна быть оценена.
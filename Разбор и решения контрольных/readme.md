# Предисловие   
Тут представленны всякие разные контрольные, которые давал в течении и в конце семестра.
Еще тут есть небольшой теорминимум, составленный мной в процессе подготовки,
необходимый для решения одного из вариантов контрольной.

# Ссылки на другие решения
[Решение 1 (нажми меня!)]

# Разбор 10 варианта   
![](https://www.linkpicture.com/q/0_39.jpg)

## 1.
### Теорминимум
Алгоритмы планирования:
* FCFS - first come, fist served (первым пришел - первым обслужен).    
Просто обычная очередь из процессов, процесс выполняется без прерывания,
пока не завершится, а после берется следующий процесс из очереди.
* SJF - shortes job first (сначала самая короткая работа).    
Очередь процессов сортируется по времени выполнения процесса.
* RR - round robin.    
Каждый процесс выполняется фиксированное небольшое время, после чего
переключаемся на другой процесс, и так пока все процессы не закончат свою работу.
* Приоритетное планирование со статическими приоритетами.
Сортируем процессы по приоритету (грубо говоря по важности процесса),
потом последовательно выполняем самый важный, пока он не завершается,
потом берется и выполняется процесс с меньшим приоритетом и т.д.

### Решение

### a)

Исходя из определений алгоритмов, ясно, что бесконечно откладываться может
процесс в следующих алгосах: 
SJF (ибо долго выполняющийся процесс будет ждать,
если все время запускать быстро выполяющиеся процессы),
Приоритетное планирование со статическими приоритетами (ибо
процесс с низким приоритетом снова будет ждать, если запускать много
процессов с высоким приоритетом).

### б) 
Режим разделения времени предполагает, что у процесса
в любой момент могут забрать или вернуть управление,
поэтому если два процесса находятся в такой ситуации
в режиме гонки, то результат не определен, поэтому
иногда возможен и правильный результат.

## 2.
### Теорминимум 
#### Динамические разделы:
Вначале вся память свободна и не разделена заранее на разделы. Вновь поступающей задаче выделяется строго необходимое количество памяти,
не более. После выгрузки процесса память временно освобождается. По истечении некоторого времени память представляет
собой переменное число разделов разного размера. Смежные свободные участки могут быть объединены.

#### Стратегии работы с памятью:
* Стратегия наиболее подходящего (Best fit).    
Процесс помещается в тот раздел, где после его загрузки останется меньше всего свободного места.
* Стратегия наименее подходящего (Worst fit).     
При помещении в самый большой раздел в нем остается достаточно места для возможного размещения еще одного процесса.
 
## 3.
### Теорминимум
* Семафор представляет собой счётчик, над которым можно выполнять две операции: увеличение на 1 и уменьшение на 1. 
При попытке уменьшения семафора, значение которого равно нулю, задача, запросившая данное действие, должна блокироваться до тех пор, пока не станет возможным уменьшение значения
семафора до неотрицательного значения, то есть пока другой процесс не увеличит значение семафора.
* Разделяемая переменная - переменная, общая для всех процессов.
* Монитор – это набор разделяемых переменных и условных переменных, в каждый момент времени только один процесс может выполянться внутри монитора (ожидание выполнением не считается).
Условная переменная монитора - переменная, у которой есть две функции - wait и signal. Первая заставляет процесс ждать до тех пор, пока другой процесс не вызовет вторую.
* Сообщения - можно посылать сообщения между процессами, send(A, mes) A - название очереди, mes - текст. receive(A) - получить из очереди сообщений. receive будет ждать сообщения.

## 4.
### Теорминимум
[Хорошее видео](https://youtu.be/1x71GUNcS2s)   

### Решение
Всего у адреса 32 бита. Но 512 = 2^9, т.е. 9 битов на сегмент.
Еще 256кб = 2^18. Т.е. на адрес 18 бит. Соответственно на страницу 32 - 18 - 9 = 5.

0x15abcd = 00000000000101011010101111001101
0x951234 = 00000000100101010001001000110100
0xfb1421 = 00000000111110110001010000100001

Перевели в двоичное представление.
Теперь разобьем на колонки по соответсвующей длине сегмента, страницы, логического адреса.
(первая - сегмент, вторая - адрес, третья - лог. адрес)

0x15abcd = 000000000 00101 011010101111001101   
0x951234 = 000000001 00101 010001001000110100    
0xfb1421 = 000000001 11110 110001010000100001       

0x15abcd = 000000000 00101 011010101111001101      
	=> сегмент 0, страница 5, берем соответствуюший номер кадра: 18 = 10010, к нему приписываем справа лог. адрес и переводим в 16тиричную, имеем 0x49ABCD.   
0x951234 = 000000001 00101 010001001000110100     
	=> сегмент 1, страница 5, такой страницы у нас нет, поэтому page fault.      
0xfb1421 = 000000001 11110 110001010000100001          
  	=> сегмент 1, важно, чтобы число, которое получается приписыванием друг к другу второй и третьей колонки были меньше соответсвующей длины сегмента, что не наблюдается здесь, поэтому error. 
